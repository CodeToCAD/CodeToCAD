{#

Nesting is formatted like this:
    className > methods > properties > parameters/information > definitions

Sample context:
    "Part": => className
        "information": => a method
            "Capabilities related to...",
        "constructor": { => a method
            "parameters": => a property
                {"name": => a parameter
                    {"type": "string"} => a definition
                },
        },
        "fromFile": { => a method
            "information": => a property
                "Create a shape from a file.",
            "parameters": => a property
                {"filePath": => a parameter
                    {"type": "string"}, => a definition
                "fileType": => a parameter
                    {"type": "string", "required": false} => a definition
                }
        }

-#}
from abc import ABCMeta, abstractmethod
from typing import Optional, Union, TypeAlias, cast

from core.utilities import Point, Dimension, Dimensions, CurveTypes, Angle, BoundaryBox, Axis

StringOrFloat: TypeAlias = Union[str, float]
IntOrFloat: TypeAlias = Union[int, float]
StringNameOrMaterial: TypeAlias = Union[str, 'Material']
StringNameOrPart: TypeAlias = Union[str, 'Part']
StringNameOrEntity: TypeAlias = Union[str, 'Entity']
StringNameOrLandmark: TypeAlias = Union[str, 'Landmark']
StringNameOrIndexOrAxis: TypeAlias = Union[str, int, Axis]
StringValueOrFloatOrDimension: TypeAlias = Union[str,float, Dimension]
StringValueOrFloatOrAngle: TypeAlias = Union[str,float, Angle]
StringNameOrEntityOrLandmark: TypeAlias = Union[str, Entity, Landmark]
StringListOrDimensions: TypeAlias = Union[str, list[str,float,Dimension], Dimensions]
StringValuesOrPoint: TypeAlias = Union[str, list[str], Point]
StringNameOrLengthUnit: TypeAlias = Union[str,LengthUnit]


{% set types = {"string":"str", "array": "list", "object": "dict", "number":"int", "float":"float", "boolean":"bool", "string,float":"StringOrFloat","int,float":"IntOrFloat", "string,Part":"StringNameOrPart", "string,Entity":"StringNameOrEntity", "list[string,Entity]":"list[StringNameOrEntity]", "string,Landmark":"StringNameOrLandmark","list[string,Landmark]":"list[StringNameOrLandmark]", "string,Material":"StringNameOrMaterial", "string,int,Axis":"StringNameOrIndexOrAxis", "string,float,Dimension":"StringValueOrFloatOrDimension","string,float,Angle":"StringValueOrFloatOrAngle", "string,Entity,Landmark": "StringNameOrEntityOrLandmark", "string,list[string,float,Dimension],Dimensions": "StringListOrDimensions", "string,list[string],Point]": "StringValuesOrPoint", "list[string,list[string],Point]": "list[StringValuesOrPoint]", "string,LengthUnit": "StringNameOrLengthUnit" -%}
{% macro typeMapping(typeName) -%}
    {{types[typeName] if typeName in types else typeName}}
{%- endmacro %}
{%- for className, methods in capabilities.items() -%}

class {{className}}({{ methods["extends"]+"," if "extends" in methods}}metaclass=ABCMeta): {# e.g. Part #}

    {%-for method, properties in methods.items() -%} {# e.g. "parameters": {"name": {"type": "string"}} #}

    {%- set parameters = properties["parameters"] if "parameters" in properties else {} -%}

    {%- if method == "information" %}
    # {{ properties }}

    {%- elif method == "extends"-%}
    {# Do nothing #}
    {%- elif method == "alias"-%}
    
    {%- set alias = properties -%}
    
    {%- elif method == "constructor"%}

    {%-for parameter, definition in parameters.items() -%} {# e.g. {"name":{"type": "string"}} #}
    {{ parameter }} {{-":" + ("Optional["+typeMapping(definition.type)+"]" if definition.required == false else typeMapping(definition.type)) if definition.type and definition.type != "any" }} {{- "=None" if definition and definition.required == false -}}
    {%-endfor%}

    def __init__(self
    {%- if parameters.keys()|length > 0 -%}
    ,
    {%-for parameter, definition in parameters.items() -%} {# e.g. {"name":{"type": "string"}} #}
    {{ parameter }} {{-":" + ("Optional["+typeMapping(definition.type)+"]" if definition.required == false else typeMapping(definition.type)) if definition.type and definition.type != "any" }} {{- "=None" if definition and definition.required == false -}} {{-"," if not loop.last}} \
    {%-endfor%}
    {%-endif%}
    ):
    {%-for parameter, definition in parameters.items() -%} {# e.g. {"name":{"type": "string"}} #}
        self.{{ parameter }} = {{parameter}}
    {%- else %}
        pass
    {%-endfor%}

    {%- else %}

    @abstractmethod
    def {{method}}(self
    {%- if parameters.keys()|length > 0 -%}
    ,
    {%-for parameter, definition in parameters.items() -%} {# e.g. {"name":{"type": "string"}} #}
    {{ parameter }} {{-":" + ("Optional["+typeMapping(definition.type)+"]" if definition.required == false else typeMapping(definition.type)) if definition.type and definition.type != "any" }} {{- "=None" if definition and definition.required == false -}} {{-", " if not loop.last}} \
    {%-endfor%}
    {%-endif%}
    ) {{-  " -> " + typeMapping(properties["returnType"]) if "returnType" in properties}}:
        print("{{method}} is called in the interface. Please override this method.") 
        {{ "return self" if "action" in properties and properties["action"] != "get" else "raise NotImplementedError" }}
    
    {%-endif-%}

    {%-endfor%}

{% endfor -%}