{%- from 'capabilities_to_py_utilities.j2' import typeMapping, typeMappingWithClassNameSuffix, generateMethodArguments %}

    {%-for methodName, properties in methods.items() -%} {# e.g. "parameters": {"name": {"type": "string"}} #}

    {%- set isStaticMethod = "staticMethod" in properties and properties["staticMethod"] -%}

    {%- set parameters = properties["parameters"] if "parameters" in properties else {} -%}

    {%- if methodName == "information" %}
    {# Do nothing #}
    {%- elif methodName == "implements"-%}
    {# Do nothing #}
    {%- elif methodName == "constructor"%}

    {%-for parameter, definition in parameters.items() -%} {# e.g. {"name":{"type": "string"}} #}
    {%set defaultValue = definition.defaultValue if "defaultValue" in definition else None-%}
    {%set defaultValue = '"'+defaultValue+'"' if defaultValue is string else defaultValue|string -%}
    {{ parameter }} {{-":" + ("Optional["+typeMapping(definition.type)+"]" if definition.required == False else typeMapping(definition.type)) if definition.type and definition.type != "any" }} {{- ("="+defaultValue if "defaultValue" in definition else "=None") if definition.required == False or "defaultValue" in definition  -}}
    {%-endfor%}

    {%-set init_parameters = parameters-%}
    {%-set superParameters = []-%}

    {%-if useAbstractMethodDecorator and "implements" in methods %}
        {%- for implementedClass in  methods["implements"].split(",") -%}
            {%- if "constructor" in capabilities[implementedClass]%}
                {%-set implementedClassParameters = capabilities[implementedClass]["constructor"]["parameters"] -%}
                {%- for parameterName in implementedClassParameters.keys() -%}
                    {%- set superParameters = superParameters.append(parameterName + "="+parameterName)-%}
                    {%- set _ = init_parameters.update({parameterName: implementedClassParameters[parameterName]}) -%}
                {%- endfor-%}
            {%-endif%}
        {%-endfor%}
    {%-endif%}

    {%-set new_init_params = {} -%}
    {%-set no_default_params = []-%}
    {%-set default_params = []-%}
    {%-for parameterName in init_parameters.keys()-%}
    {# Rearrange parameters to make sure default and not-required parameters are placed last #}
    {%-if "defaultValue" in init_parameters[parameterName] or ("required" in  init_parameters[parameterName] and init_parameters[parameterName]["required"] == false)-%}
    {%- set default_params = default_params.append(parameterName)-%}
    {%else%}
    {%- set no_default_params = no_default_params.append(parameterName)-%}
    {%-endif-%}
    {%-endfor-%}
    {%-for parameterName in no_default_params-%}
    {%- set _ = new_init_params.update({parameterName: init_parameters[parameterName]}) -%}
    {%-endfor-%}
    {%-for parameterName in default_params-%}
    {%- set _ = new_init_params.update({parameterName: init_parameters[parameterName]}) -%}
    {%-endfor%}

    {{ generateMethodArguments("__init__", new_init_params, isStaticMethod, useAbstractMethodDecorator) }}):
        {%-if useAbstractMethodDecorator  and "implements" in methods %}
        super().__init__({{ superParameters|join(", ") }})
        {%-endif%}

    {%-for parameter, definition in parameters.items() -%} {# e.g. {"name":{"type": "string"}} #}
        self.{{ parameter }} = {{parameter}}
    {%- else %}
        pass
    {%-endfor%}

    {%- elif methodName == "default"%}

    {{ generateMethodArguments(methodName, parameters, isStaticMethod, useAbstractMethodDecorator) }}) {{-  " -> " + typeMappingWithClassNameSuffix(properties["returnType"], classNameSuffix, allCodeToCADClassNames) if "returnType" in properties}}:
        {%if useAbstractMethodDecorator-%}
        raise RuntimeError()
        {%else-%}
        return {{className}}()
        {%-endif-%}

    {%- else %}

    {{ generateMethodArguments(methodName, parameters, isStaticMethod, useAbstractMethodDecorator) }}) {{-  " -> " + typeMappingWithClassNameSuffix(properties["returnType"], classNameSuffix, allCodeToCADClassNames) if "returnType" in properties}}:
        {% if "information" in properties and useAbstractMethodDecorator -%}
        '''
        {{ properties["information"] }}
        '''
        {%endif%}
        {% if useAbstractMethodDecorator -%}
        print("{{methodName}} is called in an abstract method. Please override this method.")
        {{ "return self" if "action" in properties and properties["action"] != "get" else "raise NotImplementedError()" }}
        {%else-%}
        {{ "return self" if "action" in properties and properties["action"] != "get" else "raise NotImplementedError()" }}
        {%endif%}
    
    {%-endif-%}
    {%-endfor%}
